class nodePortCheck {

    net = require('net');
    defaultOptions: any = {
        host: '0.0.0.0',
        port: 80,
        output: false,
        maxRetries: 10
    };
    options: any = {};
    server: any = {};
    retryServer: number = 0;
    portAvailable: boolean = false;
    savePorts: any = [];
    port: number = 0;
    ports: any = [];
    callback: any;
    isServerBound: boolean = false;
    serverErrors: string[] = ['EADDRINUSE', 'EADDRNOTAVAIL', 'EACCES'];

    constructor(options, callback: (isPortAvailable: boolean, availablePort: number, initialPort: number) => {}) {

        this.options = Object.assign({}, this.defaultOptions, options);

        if (typeof this.options.port !== 'object' && this.options.port.length !== 0) {

            this.ports.push(this.options.port);

        } else {

            this.ports = this.options.port;

        }

        this.savePorts = JSON.stringify(this.options.port);

        this.callback = callback;

        this.createServer();

    }

    private setCurrentPort() {

        this.port = this.ports[0];
        this.ports.shift();
        this.retryServer = 0;

    }

    private output(...input) {

        if (this.options.hasOwnProperty('output') && this.options.output === true) {

            console.log.apply(this, arguments);

        }

    }

    private canRetry() {

        let status: boolean;

        if (+this.options.maxRetries > 0 && +this.options.maxRetries === this.retryServer || this.options.maxRetries === 0) {

            this.output("Maximum retries were reached for port", this.port - this.options.maxRetries);

            if (this.ports.length === 0) {

                this.finalCallback();

                status = false;

            } else {

                this.createServer();

            }

        } else {

            +this.port++;
            +this.retryServer++;

            this.output('Server retry attempt #' + this.retryServer + " at", this.getHostAndPort());

            status = true;

        }

        if (Object.keys(this.server).length) {
            this.server.close();
        }

        return status;

    }

    private finalCallback() {

        setTimeout(() => {

            this.callback(this.portAvailable, +this.port, JSON.parse(this.savePorts));

        }, 3000);

    }

    private getHostAndPort() {
        return this.options.host + ':' + this.port;
    }

    createServer() {

        this.setCurrentPort();

        this.server = this.net.createServer();

        this.server.on('error', (err) => {

            if (+this.options.maxRetries === 0) {

                this.retryServer = 1;

                return this.canRetry();

            } else {

                if (this.serverErrors.indexOf(err.code) !== -1) {

                    if (this.canRetry()) {

                        setTimeout(() => {

                            this.server.listen(this.port, this.options.host);

                        }, 1000);

                    }

                } else {

                    throw err;

                }

            }

        });

        this.server.listen(this.port, this.options.host);

        this.server.on('listening', () => {

            this.output('Server bound to', this.getHostAndPort());
            this.isServerBound = true;

            this.server.close();

            this.server.unref();

            this.server.getConnections((error, count) => {

                if (count === 0) {

                    this.portAvailable = true;

                }

                this.finalCallback();

            });

        });

        this.server.on('close', () => {
            if (this.isServerBound) {
                this.output('Server closed - port released - done');
            }
        });

    }
}

module.exports = (options, callback) => {
    return new nodePortCheck(options, callback);
};