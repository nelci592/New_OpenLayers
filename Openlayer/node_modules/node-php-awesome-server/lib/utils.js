"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * Create options from here so we can use them both in app and tests.
     * @param {NPAS_Options} options
     * @returns {NPAS_Options}
     */
    Utils.createOptions = function (options) {
        var routerPkg = require('php-built-in-web-server-router');
        var routerDefaultPath = routerPkg.lib;
        var routerCertificate = routerPkg.cert;
        var outputDefaults = {
            startup: true,
            date: true,
            ip: true,
            statusCode: true,
            method: true,
            port: false,
            os: false,
            reqTime: false,
            browser: false,
            device: false,
        };
        var opt = {
            host: '0.0.0.0',
            port: 9000,
            env: {},
            ini_set: {},
            theme: 'php',
            ini_config: "",
            secureOrigin: true,
            middleware: function (req, res, next) {
                next();
            },
            middlewareAfter: function (req, res, next) {
                next();
            },
            root: Utils.root('..', 'public'),
            indexFile: 'index.php',
            router: routerDefaultPath,
            bin: 'php',
            clustersSet: 'auto',
            phpPerCluster: 1,
            output: outputDefaults
        };
        options = __assign({}, opt, options);
        if (typeof options.output !== "boolean") {
            options.output = __assign({}, outputDefaults, options.output);
        }
        /**
         * Add cURL certificate
         * https://curl.haxx.se/docs/caextract.html
         */
        if (!options.ini_set.hasOwnProperty('curl.cainfo')) {
            options.ini_set['curl.cainfo'] = routerCertificate;
        }
        /**
         * Format boolean values to 1 | 0
         */
        for (var item in options) {
            if (options.hasOwnProperty(item)) {
                if (typeof options[item] === 'boolean') {
                    options[item] = options[item] == true ? 1 : 0;
                }
                if (item === 'output') {
                    if (typeof options.output === 'object' && !options.output.hasOwnProperty('length')) {
                        for (var o in options[item]) {
                            if (options[item].hasOwnProperty(o) && typeof options[item][o] === 'boolean') {
                                options[item][o] = options[item][o] == true ? 1 : 0;
                            }
                        }
                    }
                }
            }
        }
        /**
         * Clean paths - root, router, indexFile
         */
        options.root = Utils.cleanInputPath(options.root);
        options.router = Utils.cleanInputPath(options.router);
        options.indexFile = Utils.cleanInputPath(options.indexFile);
        options.ini_config = Utils.cleanInputPath(options.ini_config);
        /**
         * Reset to index.php if root path is default
         */
        if (options.root === Utils.cleanInputPath(Utils.root('..', 'router'))) {
            options.indexFile = 'index.php';
        }
        /**
         * Correct phpPerCluster, defaults are based on clusterSet
         * clustersTotal = 1 -> phpPerCluster min value will be 2
         * clustersTotal >= 2 -> phpPerCluster min value will be 1
         */
        var clustersTotal = Utils.getClusters(options.clustersSet);
        if (clustersTotal <= 1) {
            /**
             * clustersTotal <= 1 -> phpPerCluster min value will be 2
             */
            if (options.phpPerCluster < 2) {
                options.phpPerCluster = 2;
            }
        }
        if (clustersTotal >= 2) {
            /**
             * clustersTotal >= 2 -> phpPerCluster min value will be 1
             */
            if (options.phpPerCluster < 1) {
                options.phpPerCluster = 1;
            }
        }
        return options;
    };
    /**
     * Return the next value from array after "val"
     * @param {number[]} arr
     * @param {number} val
     * @returns {number}
     */
    Utils.getNextAfter = function (arr, val) {
        var searchPos = arr.indexOf(val);
        var newVal = arr[0];
        if (searchPos > -1) {
            if (searchPos + 1 >= arr.length) {
                newVal = arr[0];
            }
            else {
                newVal = arr[searchPos + 1];
            }
        }
        return newVal;
    };
    /**
     * Return a random value from array
     */
    Utils.arrayRandom = function (currArray) {
        return currArray[Math.floor(Math.random() * currArray.length)];
    };
    /**
     * Detect if we have a custom router
     *      1   -   default
     *      2   -   user-defined
     *      3   -   default (fallback)
     * @param {string} customRouter
     * @param {string} defaultRouter
     * @returns {number}
     */
    Utils.detectRouterType = function (customRouter, defaultRouter) {
        if (customRouter === void 0) { customRouter = ""; }
        if (defaultRouter === void 0) { defaultRouter = ""; }
        customRouter = Utils.cleanInputPath(customRouter).toLowerCase();
        defaultRouter = Utils.cleanInputPath(defaultRouter).toLowerCase();
        return customRouter !== defaultRouter ? (require('fs').existsSync(customRouter) ? 2 : 3) : 1;
    };
    Utils.cleanInputPath = function (path) {
        return path.replace(/[/\\]+/g, "/").replace(/[\/\\]$/, "");
    };
    /**
     * Find your local network address
     * Exclude by default VMware and Docker networks
     * @param {string} matchAddress
     * @param {string[]} excludeNetworksLike
     * @returns {string}
     */
    Utils.prototype.getLocalAddress = function (matchAddress, excludeNetworksLike) {
        if (matchAddress === void 0) { matchAddress = '127.0.0.1'; }
        if (excludeNetworksLike === void 0) { excludeNetworksLike = ['vmware', 'docker']; }
        var address = matchAddress;
        var network = require('os').networkInterfaces();
        var isIPv4 = require('net').isIPv4;
        var availableNetworks = Object.keys(network);
        var foundIP = false;
        var ipList = [];
        /**
         * Filter networks
         */
        if (excludeNetworksLike.length) {
            availableNetworks = availableNetworks.filter(function (networkName) {
                var keepNetwork = true;
                excludeNetworksLike.forEach(function (eth) {
                    if (new RegExp(eth.toLowerCase()).test(networkName.toLowerCase())) {
                        keepNetwork = false;
                    }
                });
                return keepNetwork;
            });
        }
        /**
         * Retrieve IPv4 addresses base on the filtered networks
         */
        availableNetworks.forEach(function (networkName) {
            for (var _i = 0, _a = network[networkName]; _i < _a.length; _i++) {
                var item = _a[_i];
                if (item.family === 'IPv4' && item.internal === false && ipList.indexOf(item.address) === -1) {
                    ipList.push(item.address);
                }
            }
        });
        if (ipList.length) {
            ipList.forEach(function (ip) {
                if (new RegExp(matchAddress).test(ip)) {
                    address = ip;
                    foundIP = true;
                }
            });
            if (!foundIP) {
                address = ipList[0];
            }
        }
        if (!isIPv4(address)) {
            address = '127.0.0.1';
        }
        return address;
    };
    Utils.root = function () {
        var input = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            input[_i] = arguments[_i];
        }
        var path = require('path');
        var _root = path.resolve(__dirname, '..');
        input = Array.prototype.slice.call(input, 0);
        return path.join.apply(path, [_root].concat(input));
    };
    Utils.getClusters = function (clustersSet) {
        var cpus = require('os').cpus();
        var cpuCount = cpus.length;
        var clustersOptions = ['max', 'auto'];
        var clustersNr = 1;
        if (typeof clustersSet === 'string' && clustersOptions.indexOf(clustersSet.toLowerCase()) !== -1) {
            /**
             * Max CPU cores
             */
            if (clustersSet.toLowerCase() === 'max') {
                clustersNr = cpuCount;
            }
            /**
             * Custom profile
             */
            if (clustersSet.toLowerCase() === 'auto') {
                if (cpuCount === 4) {
                    clustersNr = 2;
                }
                if (cpuCount >= 8 && cpuCount < 12) {
                    clustersNr = 3;
                }
                if (cpuCount >= 12 && cpuCount < 16) {
                    clustersNr = 4;
                }
                if (cpuCount >= 16) {
                    clustersNr = 5;
                }
            }
        }
        if (!isNaN(+clustersSet) && clustersSet > 0) {
            clustersNr = +clustersSet;
        }
        if (clustersSet < 1) {
            clustersNr = 1;
        }
        return clustersNr;
    };
    Utils.getValidAddress = function (host, port, returnObject) {
        if (port === void 0) { port = 0; }
        if (returnObject === void 0) { returnObject = false; }
        var net = require('net');
        var fallbackHost = '0.0.0.0';
        if (!net.isIP(host)) {
            host = fallbackHost;
        }
        if ((port < 1 || port > 65535) || isNaN(+port)) {
            port = 0;
        }
        if (returnObject) {
            return {
                host: host,
                port: port
            };
        }
        else {
            return host + (port ? ':' + port : '');
        }
    };
    return Utils;
}());
exports.Utils = Utils;
