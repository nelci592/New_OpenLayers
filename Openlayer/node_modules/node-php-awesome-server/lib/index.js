"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var http_1 = require("http");
var servingStrategy_1 = require("./core/servingStrategy");
var utils_1 = require("./core/utils");
var nodePhpAwesomeServer = /** @class */ (function () {
    function nodePhpAwesomeServer(options) {
        var _this = this;
        this.discIssued = false;
        this.workersPID = [];
        this.phpPortsObject = {};
        this.phpPorts = [];
        this.utils = new utils_1.Utils();
        this.pid = process.pid;
        var ua = require('ua-parser2')();
        var chalk = require('chalk');
        var cluster = require('cluster');
        var routerPkg = require('php-built-in-web-server-router');
        var serve = new servingStrategy_1.ServingStrategy();
        var routerDefaultPath = routerPkg.lib;
        this.server = new (require('events'))();
        options = utils_1.Utils.createOptions(options);
        var clustersTotal = utils_1.Utils.getClusters(options.clustersSet);
        var showOutput = typeof options.output === 'object' && !options.output.hasOwnProperty('length');
        /**
         * EXPOSE Variables to PHP
         */
        var Vars = {
            OPTIONS: JSON.stringify(options),
            WORKERS: clustersTotal,
            ENVIRONMENT: JSON.stringify(options.env),
            EXPRESS_PROTOCOL: 'http',
            EXPRESS_SECURE_ORIGIN: options.secureOrigin,
            EXPRESS_HOST: options.host,
            EXPRESS_PORT: options.port,
            EXPRESS_ADDRESS: utils_1.Utils.getValidAddress(options.host, options.port),
            EXPRESS_URL: "http://" + utils_1.Utils.getValidAddress(options.host, options.port),
            MASTER_PID: process.pid,
            ROOT_PACKAGE: utils_1.Utils.root('..'),
            INI_CONFIG: options.ini_config,
            /**
             * These are declared in workers.js
             */
            WORKER_ID: "",
            WORKER_PID: "",
            ROUTER: "",
            ROUTER_DEFAULT: routerDefaultPath
        };
        var exposeVars = {};
        for (var vars in Vars) {
            exposeVars["NODE_NPAS_" + vars] = Vars[vars];
            process.env["NODE_NPAS_" + vars] = Vars[vars];
        }
        process.env["NODE_NPAS_EXPOSED_VARS"] = JSON.stringify(Object.keys(exposeVars));
        if (typeof options.ini_config === 'string' && options.ini_config.length) {
            if (options.ini_config.substr(-4, 4) !== '.ini') {
                console.log(chalk.red.bold("Your ini config doesn't have '.ini' extension: " + options.ini_config));
                this.close();
            }
            if (!require('fs').existsSync(options.ini_config)) {
                console.log(chalk.red.bold("Your ini config path is invalid: " + options.ini_config));
                this.close();
            }
        }
        if (!require('fs').existsSync(options.root)) {
            console.log(chalk.red.bold("Your root path is invalid: " + options.root));
            this.close();
        }
        else {
            cluster.setupMaster({
                exec: utils_1.Utils.root('core', 'workers.js')
            });
            for (var i = 0; i < clustersTotal; i++) {
                cluster.fork(process.env);
            }
        }
        /**
         * Update Ports if workers died and got hired.
         */
        cluster.on("fork", function () {
            _this.phpPorts = _this.reloadPHPports();
        });
        var firstTimeOnline = clustersTotal;
        /**
         * Messages Received from Workers
         */
        cluster.on('message', function (worker, message) {
            var info = JSON.parse(message);
            /**
             * Workers are announcing their online status
             * We'll emit 'connect' when all workers are online.
             *
             * or
             *
             * A worker died and a new one was created
             */
            if (info.message === 'php.server.online' && !_this.discIssued) {
                _this.phpPortsObject[info.worker.workerId] = info.worker.phpPorts;
                serve.updatePorts(_this.reloadPHPports());
                _this.workersPID.push(+worker.process.pid);
                if (showOutput && options.output.hasOwnProperty('startup')) {
                    console.log(chalk.cyan.bold(info.worker.text));
                }
                firstTimeOnline--;
                if (firstTimeOnline === 0) {
                    if (showOutput && options.output.hasOwnProperty('startup')) {
                        if (cluster.isMaster) {
                            var checkPort = require('node-port-check');
                            checkPort({
                                host: options.host,
                                port: options.port,
                                output: false
                            }, function (isPortAvailable, availablePort, initialPort) {
                                if (isPortAvailable) {
                                    options.port = availablePort;
                                    var express = require('express');
                                    var cors = require('cors');
                                    var request_1 = require('request');
                                    var router_1 = express.Router();
                                    var app = express();
                                    var fs_1 = require('fs');
                                    var listenOnHOST_1 = _this.utils.getLocalAddress();
                                    var koh = options.host;
                                    var bindGlobal_1 = options.host === '0.0.0.0' || koh === listenOnHOST_1;
                                    var server_addr_1 = bindGlobal_1 ? listenOnHOST_1 : koh;
                                    app.use(cors({ credentials: true, origin: true }));
                                    /**
                                     * Add default favicon
                                     */
                                    app.use(function (req, res, next) {
                                        serve.updatePorts(_this.phpPorts);
                                        var icons = [
                                            "favicon.ico",
                                            "favicon.png",
                                            "apple-touch-icon-120x120-precomposed.png",
                                            "apple-touch-icon-precomposed.png",
                                            "apple-touch-icon.png"
                                        ];
                                        var isIconRequested = icons.indexOf(req.url.substr(1));
                                        if (isIconRequested > -1 && !fs_1.existsSync(utils_1.Utils.root("..", options.root, icons[isIconRequested]))) {
                                            if (fs_1.existsSync(utils_1.Utils.root('..', 'router', 'icons', icons[isIconRequested]))) {
                                                res.sendFile(utils_1.Utils.root('..', 'router', 'icons', icons[isIconRequested]));
                                            }
                                            else {
                                                next();
                                            }
                                        }
                                        else {
                                            next();
                                        }
                                    });
                                    /**
                                     * Add middleware from options
                                     */
                                    if (typeof options.middleware === 'function') {
                                        router_1.use(options.middleware);
                                    }
                                    else {
                                        if (options.middleware instanceof Array) {
                                            if (typeof options.middleware[0] === 'string' && typeof options.middleware[1] === 'function' && options.middleware.length === 2) {
                                                router_1.use.apply(router_1, options.middleware);
                                            }
                                            else {
                                                options.middleware.forEach(function (middleware) {
                                                    if (middleware instanceof Array) {
                                                        router_1.use.apply(router_1, middleware);
                                                    }
                                                    else {
                                                        router_1.use(middleware);
                                                    }
                                                });
                                            }
                                        }
                                    }
                                    /**
                                     * Pipe all requests to workers
                                     * The loaded worker will send it further
                                     */
                                    router_1.use(function (req, res, next) {
                                        var _a = req.headers['host'].toString().split(":"), incomingHost = _a[0], incomingPort = _a[1];
                                        req['serveJob'] = serve.activityRequest(req);
                                        req['serveJob']['requestOptions'] = {
                                            url: req.protocol + "://127.0.0.1:" + process.pid + req.url,
                                            headers: {
                                                'HOST': incomingHost + ":" + incomingPort,
                                                /**
                                                 * NPAS_FIX_* - these values are used by PHP to adjust
                                                 *              the router logic
                                                 */
                                                'NPAS_FIX_REMOTE_ADDR': req.connection.remoteAddress,
                                                'NPAS_FIX_SERVER_NAME': incomingHost !== options.host ? incomingHost : 'localhost',
                                                'NPAS_FIX_SERVER_ADDR': server_addr_1,
                                                'NPAS_EXPRESS_HOSTNAME': incomingHost,
                                                'NPAS_EXPRESS_HOSTNAME_PORT': incomingPort,
                                                'NPAS_EXPRESS_TARGET_PORT': req['serveJob']['targetPort'],
                                                'USER_AGENT': req.headers['user-agent'],
                                            },
                                            followRedirect: false,
                                            time: true,
                                            jar: true,
                                            agent: new http_1.Agent({ keepAlive: true, maxSockets: 1 }),
                                            encoding: null,
                                            gzip: true,
                                        };
                                        next();
                                    });
                                    router_1.use(function (req, res, next) {
                                        var parserData = ua.parse(req.headers['user-agent']);
                                        var browser = parserData.ua.family;
                                        var os = parserData.os.family;
                                        var device = parserData.device.family;
                                        var outputData = {
                                            message: 'php.server.response',
                                            data: {
                                                hostPort: '',
                                                port: req['serveJob']['targetPort'],
                                                code: res.statusCode,
                                                url: req.url,
                                                ip: req.ip,
                                                xhr: req.xhr,
                                                method: req.method.toUpperCase(),
                                                browser: browser,
                                                os: os,
                                                device: device
                                            }
                                        };
                                        /**
                                         * IncommingMessage
                                         * @type {NodeJS.ReadableStream}
                                         */
                                        req.pipe(request_1(req['serveJob']['requestOptions'], function (err, resp, body) {
                                            if (err) {
                                                res.set("Content-Type", "application/json");
                                                var customMessages = [];
                                                customMessages.push("Error from master.");
                                                customMessages.push("Usually this kind of errors occurs from a corrupted output.");
                                                customMessages.push("Check the following headers to be correct: Content-Type, Content-Length.");
                                                var message_1 = {
                                                    npas: customMessages,
                                                    requestOptions: req['serveJob']['requestOptions'],
                                                    outputData: outputData,
                                                    error: err.message
                                                };
                                                res.send(JSON.stringify(message_1));
                                            }
                                            var sock = req.socket;
                                            var ipAndPort = sock._peername.address + ':' + sock._peername.port;
                                            res.status(resp.statusCode);
                                            res.statusMessage = resp.statusMessage;
                                            serve.activityResponse(resp, req['serveJob']);
                                            outputData.data['code'] = resp.statusCode;
                                            outputData.data['ip'] = ipAndPort;
                                            outputData.data['workerId'] = resp.headers['worker-id'];
                                            outputData.data['reqTime'] = resp.timingPhases.total;
                                            nodePhpAwesomeServer.outputFormat(outputData, options);
                                            var phpHeaders = {};
                                            for (var headerName in resp.headers) {
                                                if (resp.headers.hasOwnProperty(headerName)) {
                                                    phpHeaders[headerName] = resp.headers[headerName].toString().split(';').map(function (item) { return item.trim(); });
                                                    res.setHeader(headerName, resp.headers[headerName]);
                                                    if (headerName === 'content-type') {
                                                        req.headers[headerName] = resp.headers[headerName];
                                                    }
                                                }
                                            }
                                            res.locals['phpHeaders'] = phpHeaders;
                                            res.locals['phpBody'] = body;
                                            next();
                                        }));
                                    });
                                    /**
                                     * Add middlewareAfter from options
                                     */
                                    if (typeof options.middlewareAfter === 'function') {
                                        router_1.use(options.middlewareAfter);
                                    }
                                    else {
                                        if (options.middlewareAfter instanceof Array) {
                                            if (typeof options.middlewareAfter[0] === 'string' && typeof options.middlewareAfter[1] === 'function' && options.middlewareAfter.length === 2) {
                                                router_1.use.apply(router_1, options.middlewareAfter);
                                            }
                                            else {
                                                options.middlewareAfter.forEach(function (middleware) {
                                                    if (middleware instanceof Array) {
                                                        router_1.use.apply(router_1, middleware);
                                                    }
                                                    else {
                                                        router_1.use(middleware);
                                                    }
                                                });
                                            }
                                        }
                                    }
                                    router_1.use(function (req, res) {
                                        res.end(res.locals.phpBody);
                                    });
                                    app.set('trust proxy');
                                    app.disable('x-powered-by');
                                    app.use(router_1);
                                    app.listen(options.port, options.host, function () {
                                        serve.updatePorts(_this.reloadPHPports());
                                        var routerType = utils_1.Utils.detectRouterType(options.router, routerDefaultPath);
                                        var routerTypeAlias = chalk.cyan.bold("default");
                                        if (routerType === 2) {
                                            routerTypeAlias = chalk.yellow.bold("user-defined");
                                        }
                                        if (routerType === 3) {
                                            routerTypeAlias = chalk.red.bold("default (fallback)");
                                        }
                                        if (typeof options.ini_config === 'string' && options.ini_config.length) {
                                            console.log(chalk.cyan.bold('INI CONFIG:', options.ini_config));
                                        }
                                        console.log(chalk.cyan.bold('DOCUMENT ROOT:', info.worker.docRoot));
                                        console.log(chalk.cyan.bold('ROUTER:', routerType === 1 ? 'default' : routerTypeAlias + " | " + info.worker.router));
                                        console.log(chalk.cyan.bold('LINK:', "http://localhost:" + options.port));
                                        if (bindGlobal_1) {
                                            console.log(chalk.cyan.bold('EXTERNAL:', "http://" + listenOnHOST_1 + ":" + options.port));
                                        }
                                        _this.server.emit('connect');
                                    });
                                }
                                else {
                                    console.log("Port " + initialPort + " is not available, last tried port was", availablePort);
                                }
                            });
                        }
                    }
                }
            }
            /**
             * There was a problem with ExpressJS - check host:port availability
             */
            if (info.message === 'kill.master') {
                setTimeout(function () {
                    if (!_this.discIssued) {
                        console.log("Check your host and port:", info.err);
                        _this.close();
                    }
                }, 100);
            }
        });
        /**
         * Create a new worker upon failure.
         */
        cluster.on('exit', function (worker) {
            if (_this.discIssued === false) {
                /**
                 * Clean up phpPortsObject
                 */
                if (_this.phpPortsObject.hasOwnProperty(worker.id)) {
                    delete _this.phpPortsObject[worker.id];
                }
                console.log(chalk.red.bold("Worker " + worker.id + " died!"), chalk.yellow.bold("Hiring a new one ..."));
                /**
                 * With a new cluster comes a new workers.js
                 * Therefore a new 'php.server.online' message
                 */
                cluster.fork(process.env);
            }
            else {
                worker.destroy();
            }
        });
    }
    nodePhpAwesomeServer.prototype.reloadPHPports = function () {
        var _this = this;
        this.phpPorts = [];
        for (var item in this.phpPortsObject) {
            this.phpPortsObject[item].forEach(function (port) {
                _this.phpPorts.push(port);
            });
        }
        return this.phpPorts;
    };
    nodePhpAwesomeServer.prototype.on = function (event, callback) {
        this.server.on(event, callback);
        return this;
    };
    nodePhpAwesomeServer.prototype.close = function () {
        var _this = this;
        this.server.emit('close');
        this.discIssued = true;
        setTimeout(function () {
            _this.workersPID.forEach(function (worker) {
                console.log('killed', worker);
                process.kill(worker);
            });
        }, 500);
        return this;
    };
    ;
    nodePhpAwesomeServer.outputFormat = function (info, options) {
        var chalk = require('chalk');
        var dateFormat = require('dateformat');
        var now = new Date();
        var fullOutput = [];
        /**
         * Worker id and URL will always output
         */
        var workerId = "[W" + info.data.workerId + "]";
        var url = info.data.url;
        /**
         * Output Config Values
         */
        var date = "[" + dateFormat(now) + " " + now.getFullYear() + "]";
        var ip = info.data.ip;
        var os = "[" + info.data.os + "]";
        var browser = "[" + info.data.browser + "]";
        var device = "[" + info.data.device + "]";
        var statusCode = "[" + info.data.code + "]";
        var method = "[" + info.data.method + "]" + (info.data.xhr ? "[XHR]" : '');
        /**
         * Format port
         */
        var port = info.data.port;
        var prefixPort = "";
        for (var i = 0; i < (5 - (port.toString()).length); i++) {
            prefixPort += " ";
        }
        port = "[" + prefixPort + port + "]";
        /**
         * Format reqTime
         * @type {string}
         */
        var reqTime = Math.round(info.data.reqTime).toString();
        var timeSuffix = parseInt(reqTime) > 999 ? 's' : 'ms';
        reqTime = (parseInt(reqTime) > 999 ? parseInt(reqTime) / 1000 : reqTime).toString();
        reqTime = "[" + reqTime + timeSuffix + "]";
        if (typeof options.output === 'object' && !options.output.hasOwnProperty('length')) {
            fullOutput.push(workerId);
            if (options.output.port) {
                fullOutput.push(port);
            }
            if (options.output.date) {
                fullOutput.push(date);
            }
            if (options.output.ip) {
                fullOutput.push(ip);
            }
            if (options.output.os) {
                fullOutput.push(os);
            }
            if (options.output.browser) {
                fullOutput.push(browser);
            }
            if (options.output.device) {
                fullOutput.push(device);
            }
            if (options.output.statusCode && options.output.method) {
                fullOutput.push("" + statusCode + method);
            }
            else {
                if (options.output.statusCode) {
                    fullOutput.push(statusCode);
                }
                if (options.output.method) {
                    fullOutput.push(method);
                }
            }
            if (options.output.reqTime) {
                fullOutput.push(reqTime);
            }
            fullOutput = fullOutput.join(' ') + ": " + url;
            /**
             * Ok
             */
            if (info.data.code === 200 || info.data.code === 201 || info.data.code === 204) {
                fullOutput = chalk.green.bold(fullOutput);
            }
            /**
             * Cached
             */
            if (info.data.code === 304) {
                fullOutput = chalk.cyan.bold(fullOutput);
            }
            if (info.data.code >= 300 && info.data.code !== 304 && info.data.code < 400) {
                fullOutput = chalk.yellow.bold(fullOutput);
            }
            /**
             * Errors
             */
            if (info.data.code >= 400) {
                fullOutput = chalk.red.bold(fullOutput);
            }
            console.log(fullOutput);
        }
    };
    return nodePhpAwesomeServer;
}());
module.exports = function (options) {
    return new nodePhpAwesomeServer(options);
};
