"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var phpserver_1 = require("./phpserver");
var http_1 = require("http");
var utils_1 = require("./utils");
var Workers = /** @class */ (function () {
    function Workers(options) {
        this.npas = {};
        this.utils = new utils_1.Utils();
        var cluster = require('cluster');
        var chalk = require('chalk');
        /**
         * Express Server
         */
        var express = require('express');
        var request = require('request');
        var router = express.Router();
        var app = express();
        var workersPID = [];
        process.env.NODE_NPAS_WORKER_PID = process.pid.toString();
        process.env.NODE_NPAS_WORKER_PIDS = JSON.stringify(workersPID);
        var createPort = +process.pid;
        var onlinePHPInstances = 0;
        var phpPorts = [];
        var lastUsedPort = process.pid;
        var _loop_1 = function (i) {
            /**
             * Start PHP Server
             */
            process.env.NODE_NPAS_ROUTER = options.router;
            this_1.npas[i] = Workers.createPHPInstance(createPort, options, cluster, (i + 1));
            var phpInstance = this_1.npas[i].php;
            phpInstance.on('close', function () {
                console.log(chalk.red.bold("PHP #" + phpInstance.instanceNr + " stopped ... eliminating Worker " + phpInstance.workerId + " " + (phpInstance.instanceNr > 1 ? "and his friends " : "") + "..."));
                try {
                    process.kill(phpInstance.workerPid);
                }
                catch (e) {
                }
            });
            /**
             * Update port with PID from the previous PHP Instance
             * @type {number}
             */
            phpPorts.push(+createPort);
            createPort = this_1.npas[i].php.pid;
            /**
             * Signal Master that this worker is ready
             */
            this_1.npas[i].on('connect', function (php) {
                ++onlinePHPInstances;
                var connectInfo = {
                    message: 'php.server.online',
                    worker: {
                        text: "Worker " + cluster.worker.id + " hired - PID " + process.pid,
                        docRoot: options.root,
                        router: options.router,
                        workerId: php.workerId,
                        workerPID: php.pid,
                        phpPorts: phpPorts,
                        workerPort: createPort
                    }
                };
                /**
                 * All PHP Instances are up.
                 * Time to start worker server and tell MasterCluster that we're starting workers.
                 */
                if (options.phpPerCluster == onlinePHPInstances) {
                    router.use(function (req, res, next) {
                        var _a = req.headers['host'].toString().split(":"), fallbackHost = _a[0], fallbackPort = _a[1];
                        var _b = req.headers, incomingHost = _b.npas_express_hostname, incomingPort = _b.npas_express_hostname_port, phpPort = _b.npas_express_target_port, userAgent = _b.user_agent;
                        /**
                         * In case of "undefined" port, usually encountered when bypassing MASTER cluster
                         * and targeting a worker PORT (e.g. http://127.0.0.1:NODE_NPAS_MASTER_PID/)
                         * but most importantly if you have Apache/Nginx on port 80
                         * the invalid url (http://127.0.0.1:undefined/) will fallback
                         * to http://127.0.0.1 and these web-servers will try to resolve the path.
                         *
                         * Solution: Assign a port from the Worker's phpPorts list
                         */
                        if (typeof phpPort === 'undefined') {
                            phpPort = utils_1.Utils.getNextAfter(phpPorts, lastUsedPort).toString();
                            req.headers['npas_express_target_port'] = phpPort;
                        }
                        lastUsedPort = phpPort;
                        var requestOptions = {
                            url: req.protocol + "://127.0.0.1:" + phpPort + req.url,
                            headers: {
                                /**
                                 * NPAS_SET_HEADER_* - will set a header when PHP is loaded
                                 */
                                'NPAS_SET_HEADER_WORKER_ID': cluster.worker.id,
                                'NPAS_SET_HEADER_X_POWERED_BY': 'Node PHP Awesome Server',
                                'HOST': (incomingHost || fallbackHost) + ":" + (incomingPort || fallbackPort),
                                'NPAS_EXPRESS_HOSTNAME': incomingHost || fallbackHost,
                                'NPAS_EXPRESS_HOSTNAME_PORT': incomingPort || fallbackPort,
                                'NPAS_EXPRESS_TARGET_PORT': phpPort,
                                'NPAS_WORKER_ID': cluster.worker.id,
                                'USER_AGENT': userAgent,
                            },
                            followRedirect: false,
                            jar: true,
                            agent: new http_1.Agent({ keepAlive: true, maxSockets: 1 }),
                            encoding: null,
                            gzip: true
                        };
                        /**
                         * IncommingMessage
                         * @type {NodeJS.ReadableStream}
                         */
                        var phpPipe = req.pipe(request(requestOptions));
                        /**
                         * ServerResponse
                         * @type {NodeJS.WritableStream}
                         */
                        phpPipe
                            .on('response', function (response) {
                            if (response.statusCode === 0) {
                                response.statusCode = res.statusCode;
                            }
                            /**
                             * Make sure worker_id is present
                             * It gets lost during php redirects
                             */
                            if (typeof response.headers['worker-id'] === 'undefined') {
                                response.headers['worker-id'] = cluster.worker.id;
                            }
                            res.header('worker-id', response.headers['worker-id'].toString());
                            phpPipe.pipe(res);
                            phpPipe.on('end', function () {
                                next();
                            });
                        })
                            .on('error', function (err) {
                            res.set("Content-Type", "application/json");
                            var customMessages = [];
                            customMessages.push("Error from workers.");
                            customMessages.push("Usually this kind of errors occurs from a corrupted output.");
                            customMessages.push("Check the following headers to be correct: Content-Type, Content-Length.");
                            var message = {
                                npas: customMessages,
                                requestOptions: requestOptions,
                                error: err.message,
                                headers: res.getHeaders()
                            };
                            res.send(JSON.stringify(message));
                        });
                    });
                    app.set('trust proxy');
                    app.use(router);
                    app.listen(process.env.NODE_NPAS_MASTER_PID, '127.0.0.1', function () {
                        process.send(JSON.stringify(connectInfo));
                    }).on('error', function (err) {
                        process.send(JSON.stringify({
                            message: 'kill.master',
                            err: err.message
                        }));
                    });
                }
            });
        };
        var this_1 = this;
        for (var i = 0; i < options.phpPerCluster; i++) {
            _loop_1(i);
        }
    }
    Workers.createPHPInstance = function (createPort, options, cluster, instanceNr) {
        return new phpserver_1.PHPServer(__assign({}, options, {
            host: '127.0.0.1',
            port: createPort
        }), cluster.worker.id, cluster.worker.pid, instanceNr);
    };
    return Workers;
}());
exports.Workers = Workers;
new Workers(JSON.parse(process.env.NODE_NPAS_OPTIONS));
